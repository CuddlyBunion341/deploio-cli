#!/usr/bin/env ruby

require 'json'
require 'open3'

STDOUT.sync = true

def extract_global_flags(argv, default_org_prefix: 'renuo')
  args = argv.dup
  org_prefix = default_org_prefix
  if (idx = args.index('--org-prefix')) && args[idx+1]
    org_prefix = args[idx+1]
    args.slice!(idx, 2)
  end
  dry_run = args.delete('--dry-run') ? true : false
  [args, org_prefix, dry_run]
end

def usage(exit_code = 1)
  message = <<~USAGE
    dapp (deplo.io app CLI)

    Usage:
      dapp [--org-prefix <prefix>] [--dry-run] [--help]
      dapp <command> [args]

    Commands:
      new <project-env>                    Create project and app (git url inferred)
      list                                 List apps as <project>-<env>
      logs <project-env> [-- ...args]      Stream logs for app
      exec <project-env> [-- ...args]      Exec into app (args passed to nctl)
      stats <project-env>                  Show app stats
      config <project-env>                 Show app config (yaml)
      config:edit <project-env>            Edit app config
      hosts <project-env>                  Print app hosts

    Global flags (must appear before the command):
      --org-prefix <prefix>                Default: renuo
      --dry-run                            Print commands without executing
      --help                               Show nctl help for a command. If a
                                           command is provided (e.g. "dapp logs --help"),
                                           shows help for the underlying nctl
                                           command and bypasses other flags. If no
                                           command is provided, shows top-level
                                           nctl help.

    Examples:
      dapp new fizzbuzz-main
      dapp logs fizzbuzz-main
      dapp exec fizzbuzz-main -- -c 'echo hi'
  USAGE
  puts message
  exit exit_code
end

class AppRef
  attr_reader :project_short, :environment, :org_prefix
  def initialize(project_env, org_prefix)
    parts = project_env.split('-')
    raise "invalid <project-env>: #{project_env}" if parts.size < 2
    @environment = parts.pop
    @project_short = parts.join('-')
    @org_prefix = org_prefix
  end
  def project_full
    [org_prefix, project_short].join('-')
  end
  def app_name
    environment
  end
  def git_url
    "git@github.com:#{org_prefix}/#{project_short}.git"
  end
end

class Runner
  def initialize(dry_run: false)
    @dry_run = dry_run
  end
  def run(cmd)
    puts "> #{cmd}"
    return true if @dry_run
    system(cmd)
  end
  def capture(cmd)
    puts "> #{cmd}"
    return ["", "", 0] if @dry_run
    stdout, stderr, status = Open3.capture3(cmd)
    [stdout, stderr, status.exitstatus]
  end
end

def nctl_app_cmd(action, ref)
  "nctl #{action} app #{ref.app_name} --project #{ref.project_full}"
end

COMMANDS = {
  'new' => {
    help: 'nctl create app --help',
    run: ->(args, org_prefix, runner) {
      raise 'missing <project-env>' if args.empty?
      ref = AppRef.new(args.shift, org_prefix)
      stdout, _stderr, _code = runner.capture("nctl get projects -o json")
      existing = []
      begin
        json = JSON.parse(stdout)
        if json.is_a?(Array)
          existing = json.map { |p| p.dig('metadata', 'name') }.compact
        elsif json.is_a?(Hash) && json['items'].is_a?(Array)
          existing = json['items'].map { |p| p.dig('metadata', 'name') }.compact
        end
      rescue JSON::ParserError
        existing = []
      end
      unless existing.include?(ref.project_full)
        ok = runner.run("nctl create project #{ref.project_full}")
        exit 1 unless ok
      end
      ok = runner.run("nctl create app #{ref.app_name} --project #{ref.project_full} --git-url #{ref.git_url} --git-revision \"#{ref.environment}\" --size=mini")
      exit 1 unless ok
    }
  },
  'list' => {
    help: 'nctl get apps --help',
    run: ->(_args, org_prefix, runner) {
      runner.run("nctl get apps -A -o json | jq -r '.[] | (.metadata.namespace + "-" + .metadata.name | gsub(\"#{org_prefix}-\"; \"\"))'")
    }
  },
  'logs' => {
    help: 'nctl logs app --help',
    run: ->(args, org_prefix, runner) {
      raise 'missing <project-env>' if args.empty?
      ref = AppRef.new(args.shift, org_prefix)
      extra = args.empty? ? '' : ' ' + args.join(' ')
      runner.run(nctl_app_cmd('logs', ref) + extra)
    }
  },
  'exec' => {
    help: 'nctl exec app --help',
    run: ->(args, org_prefix, runner) {
      raise 'missing <project-env>' if args.empty?
      ref = AppRef.new(args.shift, org_prefix)
      extra = args.empty? ? '' : ' ' + args.join(' ')
      runner.run(nctl_app_cmd('exec', ref) + extra)
    }
  },
  'stats' => {
    help: 'nctl get app --help',
    run: ->(args, org_prefix, runner) {
      raise 'missing <project-env>' if args.empty?
      ref = AppRef.new(args.shift, org_prefix)
      runner.run(nctl_app_cmd('get', ref) + ' -o stats')
    }
  },
  'config' => {
    help: 'nctl get app --help',
    run: ->(args, org_prefix, runner) {
      raise 'missing <project-env>' if args.empty?
      ref = AppRef.new(args.shift, org_prefix)
      runner.run(nctl_app_cmd('get', ref) + ' -o yaml')
    }
  },
  'config:edit' => {
    help: 'nctl edit app --help',
    run: ->(args, org_prefix, runner) {
      raise 'missing <project-env>' if args.empty?
      ref = AppRef.new(args.shift, org_prefix)
      runner.run(nctl_app_cmd('edit', ref))
    }
  },
  'hosts' => {
    help: 'nctl get app --help',
    run: ->(args, org_prefix, runner) {
      raise 'missing <project-env>' if args.empty?
      ref = AppRef.new(args.shift, org_prefix)
      runner.run(nctl_app_cmd('get', ref) + " -o json | jq -r '.status.atProvider.hosts | map(.name) | .[]'")
    }
  }
}.freeze

if ARGV.include?("--help")
  args_ng, _org, dry_for_help = extract_global_flags(ARGV)
  args_ng.delete('--help')
  dapp_cmd = args_ng[0]
  if dapp_cmd.nil?
    usage(0)
  elsif COMMANDS[dapp_cmd]
    help_cmd = COMMANDS[dapp_cmd][:help]
    if dry_for_help
      puts "> #{help_cmd}"
      exit 0
    else
      exec(help_cmd)
    end
  else
    usage
  end
end

args, org_prefix, dry_run = extract_global_flags(ARGV)

usage if args.empty?

cmd = args.shift
runner = Runner.new(dry_run: dry_run)
action = COMMANDS[cmd]
usage unless action
action[:run].call(args, org_prefix, runner)
